<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Macro expansion - RustcDevGuideZh</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">1.</strong> 中文版介绍</a></li><li class="chapter-item "><a href="about.html"><strong aria-hidden="true">2.</strong> 关于</a></li><li class="chapter-item "><a href="getting_start.html"><strong aria-hidden="true">3.</strong> Getting Start</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">构建与调试rustc  (Building and debugging rustc)</li><li class="chapter-item "><a href="building/how-to-build-and-run.html"><strong aria-hidden="true">4.</strong> 如何构建和运行 Rust 编译器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="building/prerequisites.html"><strong aria-hidden="true">4.1.</strong> Prerequisites</a></li><li class="chapter-item "><a href="building/suggested.html"><strong aria-hidden="true">4.2.</strong> Suggested Workflows</a></li><li class="chapter-item "><a href="building/build-install-distribution-artifacts.html"><strong aria-hidden="true">4.3.</strong> Distribution artifacts</a></li><li class="chapter-item "><a href="building/compiler-documenting.html"><strong aria-hidden="true">4.4.</strong> Documenting Compiler</a></li><li class="chapter-item "><a href="rustdoc.html"><strong aria-hidden="true">4.5.</strong> Rustdoc</a></li><li class="chapter-item "><a href="building/ctags.html"><strong aria-hidden="true">4.6.</strong> ctags</a></li><li class="chapter-item "><a href="building/new-target.html"><strong aria-hidden="true">4.7.</strong> Adding a new target</a></li></ol></li><li class="chapter-item "><a href="tests/intro.html"><strong aria-hidden="true">5.</strong> The compiler testing framework</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tests/running.html"><strong aria-hidden="true">5.1.</strong> Running tests</a></li><li class="chapter-item "><a href="tests/adding.html"><strong aria-hidden="true">5.2.</strong> Adding new tests</a></li><li class="chapter-item "><a href="compiletest.html"><strong aria-hidden="true">5.3.</strong> Using compiletest commands to control test execution</a></li></ol></li><li class="chapter-item "><a href="compiler-debugging.html"><strong aria-hidden="true">6.</strong> Debugging the Compiler</a></li><li class="chapter-item "><a href="profiling.html"><strong aria-hidden="true">7.</strong> Profiling the compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="profiling/with_perf.html"><strong aria-hidden="true">7.1.</strong> with the linux perf tool</a></li></ol></li><li class="chapter-item "><a href="crates-io.html"><strong aria-hidden="true">8.</strong> crates.io Dependencies</a></li><li class="chapter-item affix "><li class="part-title">为 Rust 做贡献 (Contributing to Rust)</li><li class="chapter-item "><a href="contributing.html"><strong aria-hidden="true">9.</strong> 介绍</a></li><li class="chapter-item "><a href="compiler-team.html"><strong aria-hidden="true">10.</strong> About the compiler team</a></li><li class="chapter-item "><a href="git.html"><strong aria-hidden="true">11.</strong> Using Git</a></li><li class="chapter-item "><a href="rustbot.html"><strong aria-hidden="true">12.</strong> Mastering @rustbot</a></li><li class="chapter-item "><a href="walkthrough.html"><strong aria-hidden="true">13.</strong> Walkthrough: a typical contribution</a></li><li class="chapter-item "><a href="bug-fix-procedure.html"><strong aria-hidden="true">14.</strong> Bug Fix Procedure</a></li><li class="chapter-item "><a href="implementing_new_features.html"><strong aria-hidden="true">15.</strong> Implementing new features</a></li><li class="chapter-item "><a href="stability.html"><strong aria-hidden="true">16.</strong> Stability attributes</a></li><li class="chapter-item "><a href="stabilization_guide.html"><strong aria-hidden="true">17.</strong> Stabilizing Features</a></li><li class="chapter-item "><a href="feature-gates.html"><strong aria-hidden="true">18.</strong> Feature Gates</a></li><li class="chapter-item "><a href="conventions.html"><strong aria-hidden="true">19.</strong> Coding conventions</a></li><li class="chapter-item "><a href="notification-groups/about.html"><strong aria-hidden="true">20.</strong> Notification groups</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="notification-groups/arm.html"><strong aria-hidden="true">20.1.</strong> ARM</a></li><li class="chapter-item "><a href="notification-groups/cleanup-crew.html"><strong aria-hidden="true">20.2.</strong> Cleanup Crew</a></li><li class="chapter-item "><a href="notification-groups/llvm.html"><strong aria-hidden="true">20.3.</strong> LLVM</a></li><li class="chapter-item "><a href="notification-groups/risc-v.html"><strong aria-hidden="true">20.4.</strong> RISC-V</a></li><li class="chapter-item "><a href="notification-groups/windows.html"><strong aria-hidden="true">20.5.</strong> Windows</a></li></ol></li><li class="chapter-item "><a href="licenses.html"><strong aria-hidden="true">21.</strong> Licenses</a></li><li class="chapter-item affix "><li class="part-title">编译器架构概要 (High-level Compiler Architecture)</li><li class="chapter-item "><a href="part-2-intro.html"><strong aria-hidden="true">22.</strong> 序言</a></li><li class="chapter-item "><a href="overview.html"><strong aria-hidden="true">23.</strong> Overview of the Compiler</a></li><li class="chapter-item "><a href="compiler-src.html"><strong aria-hidden="true">24.</strong> The compiler source code</a></li><li class="chapter-item "><a href="building/bootstrapping.html"><strong aria-hidden="true">25.</strong> Bootstrapping</a></li><li class="chapter-item "><a href="query.html"><strong aria-hidden="true">26.</strong> Queries: demand-driven compilation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="queries/query-evaluation-model-in-detail.html"><strong aria-hidden="true">26.1.</strong> The Query Evaluation Model in Detail</a></li><li class="chapter-item "><a href="queries/incremental-compilation.html"><strong aria-hidden="true">26.2.</strong> Incremental compilation</a></li><li class="chapter-item "><a href="queries/incremental-compilation-in-detail.html"><strong aria-hidden="true">26.3.</strong> Incremental compilation In Detail</a></li><li class="chapter-item "><a href="incrcomp-debugging.html"><strong aria-hidden="true">26.4.</strong> Debugging and Testing</a></li><li class="chapter-item "><a href="queries/profiling.html"><strong aria-hidden="true">26.5.</strong> Profiling Queries</a></li><li class="chapter-item "><a href="salsa.html"><strong aria-hidden="true">26.6.</strong> Salsa</a></li></ol></li><li class="chapter-item "><a href="memory.html"><strong aria-hidden="true">27.</strong> Memory Management in Rustc</a></li><li class="chapter-item "><a href="serialization.html"><strong aria-hidden="true">28.</strong> Serialization in Rustc</a></li><li class="chapter-item "><a href="parallel-rustc.html"><strong aria-hidden="true">29.</strong> Parallel Compilation</a></li><li class="chapter-item "><a href="rustdoc-internals.html"><strong aria-hidden="true">30.</strong> Rustdoc</a></li><li class="chapter-item affix "><li class="part-title">源码表示 (Source Code Representation)</li><li class="chapter-item "><a href="part-3-intro.html"><strong aria-hidden="true">31.</strong> 序言</a></li><li class="chapter-item "><a href="cli.html"><strong aria-hidden="true">32.</strong> 命令行参数</a></li><li class="chapter-item "><a href="rustc-driver.html"><strong aria-hidden="true">33.</strong> Rustc Driver 和 Rustc Interface</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rustc-driver-interacting-with-the-ast.html"><strong aria-hidden="true">33.1.</strong> 示例：通过 rustc_interface 进行类型检查</a></li><li class="chapter-item "><a href="rustc-driver-getting-diagnostics.html"><strong aria-hidden="true">33.2.</strong> 示例：通过 rustc_interface 获取诊断信息</a></li></ol></li><li class="chapter-item expanded "><a href="syntax-intro.html"><strong aria-hidden="true">34.</strong> Syntax and the AST</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="the-parser.html"><strong aria-hidden="true">34.1.</strong> Lexing and Parsing</a></li><li class="chapter-item expanded "><a href="macro-expansion.html" class="active"><strong aria-hidden="true">34.2.</strong> Macro expansion</a></li><li class="chapter-item "><a href="name-resolution.html"><strong aria-hidden="true">34.3.</strong> Name resolution</a></li><li class="chapter-item "><a href="test-implementation.html"><strong aria-hidden="true">34.4.</strong> #[test] Implementation</a></li><li class="chapter-item "><a href="panic-implementation.html"><strong aria-hidden="true">34.5.</strong> Panic Implementation</a></li><li class="chapter-item "><a href="ast-validation.html"><strong aria-hidden="true">34.6.</strong> AST Validation</a></li><li class="chapter-item "><a href="feature-gate-ck.html"><strong aria-hidden="true">34.7.</strong> Feature Gate Checking</a></li></ol></li><li class="chapter-item "><a href="hir.html"><strong aria-hidden="true">35.</strong> The HIR (High-level IR)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lowering.html"><strong aria-hidden="true">35.1.</strong> Lowering AST to HIR</a></li><li class="chapter-item "><a href="hir-debugging.html"><strong aria-hidden="true">35.2.</strong> Debugging</a></li></ol></li><li class="chapter-item "><a href="mir/index.html"><strong aria-hidden="true">36.</strong> The MIR (Mid-level IR)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="mir/construction.html"><strong aria-hidden="true">36.1.</strong> THIR and MIR construction</a></li><li class="chapter-item "><a href="mir/visitor.html"><strong aria-hidden="true">36.2.</strong> MIR visitor and traversal</a></li><li class="chapter-item "><a href="mir/passes.html"><strong aria-hidden="true">36.3.</strong> MIR passes: getting the MIR for a function</a></li></ol></li><li class="chapter-item "><a href="identifiers.html"><strong aria-hidden="true">37.</strong> Identifiers in the Compiler</a></li><li class="chapter-item "><a href="closure.html"><strong aria-hidden="true">38.</strong> Closure expansion</a></li><li class="chapter-item affix "><li class="part-title">静态分析 (Analysis)</li><li class="chapter-item "><a href="part-4-intro.html"><strong aria-hidden="true">39.</strong> 序言</a></li><li class="chapter-item "><a href="ty.html"><strong aria-hidden="true">40.</strong> The ty module: representing types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics.html"><strong aria-hidden="true">40.1.</strong> Generics and substitutions</a></li><li class="chapter-item "><a href="ty-fold.html"><strong aria-hidden="true">40.2.</strong> TypeFolder and TypeFoldable</a></li><li class="chapter-item "><a href="generic_arguments.html"><strong aria-hidden="true">40.3.</strong> Generic arguments</a></li></ol></li><li class="chapter-item "><a href="type-inference.html"><strong aria-hidden="true">41.</strong> Type inference</a></li><li class="chapter-item "><a href="traits/resolution.html"><strong aria-hidden="true">42.</strong> Trait solving</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="early-late-bound.html"><strong aria-hidden="true">42.1.</strong> Early and Late Bound Parameters</a></li><li class="chapter-item "><a href="traits/hrtb.html"><strong aria-hidden="true">42.2.</strong> Higher-ranked trait bounds</a></li><li class="chapter-item "><a href="traits/caching.html"><strong aria-hidden="true">42.3.</strong> Caching subtleties</a></li><li class="chapter-item "><a href="traits/specialization.html"><strong aria-hidden="true">42.4.</strong> Specialization</a></li><li class="chapter-item "><a href="traits/chalk.html"><strong aria-hidden="true">42.5.</strong> Chalk-based trait solving</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/lowering-to-logic.html"><strong aria-hidden="true">42.5.1.</strong> Lowering to logic</a></li><li class="chapter-item "><a href="traits/goals-and-clauses.html"><strong aria-hidden="true">42.5.2.</strong> Goals and clauses</a></li><li class="chapter-item "><a href="traits/canonical-queries.html"><strong aria-hidden="true">42.5.3.</strong> Canonical queries</a></li></ol></li></ol></li><li class="chapter-item "><a href="type-checking.html"><strong aria-hidden="true">43.</strong> Type checking</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="method-lookup.html"><strong aria-hidden="true">43.1.</strong> Method Lookup</a></li><li class="chapter-item "><a href="variance.html"><strong aria-hidden="true">43.2.</strong> Variance</a></li><li class="chapter-item "><a href="opaque-types-type-alias-impl-trait.html"><strong aria-hidden="true">43.3.</strong> Opaque Types</a></li></ol></li><li class="chapter-item "><a href="pat-exhaustive-checking.html"><strong aria-hidden="true">44.</strong> Pattern and Exhaustiveness Checking</a></li><li class="chapter-item "><a href="mir/dataflow.html"><strong aria-hidden="true">45.</strong> MIR dataflow</a></li><li class="chapter-item "><a href="borrow_check.html"><strong aria-hidden="true">46.</strong> The borrow checker</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrow_check/moves_and_initialization.html"><strong aria-hidden="true">46.1.</strong> Tracking moves and initialization</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrow_check/moves_and_initialization/move_paths.html"><strong aria-hidden="true">46.1.1.</strong> Move paths</a></li></ol></li><li class="chapter-item "><a href="borrow_check/type_check.html"><strong aria-hidden="true">46.2.</strong> MIR type checker</a></li><li class="chapter-item "><a href="borrow_check/region_inference.html"><strong aria-hidden="true">46.3.</strong> Region inference</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrow_check/region_inference/constraint_propagation.html"><strong aria-hidden="true">46.3.1.</strong> Constraint propagation</a></li><li class="chapter-item "><a href="borrow_check/region_inference/lifetime_parameters.html"><strong aria-hidden="true">46.3.2.</strong> Lifetime parameters</a></li><li class="chapter-item "><a href="borrow_check/region_inference/member_constraints.html"><strong aria-hidden="true">46.3.3.</strong> Member constraints</a></li><li class="chapter-item "><a href="borrow_check/region_inference/placeholders_and_universes.html"><strong aria-hidden="true">46.3.4.</strong> Placeholders and universes</a></li><li class="chapter-item "><a href="borrow_check/region_inference/closure_constraints.html"><strong aria-hidden="true">46.3.5.</strong> Closure constraints</a></li><li class="chapter-item "><a href="borrow_check/region_inference/error_reporting.html"><strong aria-hidden="true">46.3.6.</strong> Error reporting</a></li></ol></li><li class="chapter-item "><a href="borrow_check/two_phase_borrows.html"><strong aria-hidden="true">46.4.</strong> Two-phase-borrows</a></li></ol></li><li class="chapter-item "><a href="param_env.html"><strong aria-hidden="true">47.</strong> Parameter Environments</a></li><li class="chapter-item "><a href="diagnostics.html"><strong aria-hidden="true">48.</strong> Errors and Lints</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="diagnostics/sessiondiagnostic.html"><strong aria-hidden="true">48.1.</strong> Creating Errors With SessionDiagnostic</a></li><li class="chapter-item "><a href="diagnostics/lintstore.html"><strong aria-hidden="true">48.2.</strong> LintStore</a></li><li class="chapter-item "><a href="diagnostics/diagnostic-codes.html"><strong aria-hidden="true">48.3.</strong> Diagnostic Codes</a></li></ol></li><li class="chapter-item "><li class="part-title">从 MIR 到 二进制 (MIR to Binaries)</li><li class="chapter-item "><a href="part-5-intro.html"><strong aria-hidden="true">49.</strong> 序言</a></li><li class="chapter-item "><a href="mir/optimizations.html"><strong aria-hidden="true">50.</strong> MIR 优化</a></li><li class="chapter-item "><a href="mir/debugging.html"><strong aria-hidden="true">51.</strong> Debugging</a></li><li class="chapter-item "><a href="const-eval.html"><strong aria-hidden="true">52.</strong> Constant evaluation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="miri.html"><strong aria-hidden="true">52.1.</strong> miri const evaluator</a></li></ol></li><li class="chapter-item "><a href="backend/monomorph.html"><strong aria-hidden="true">53.</strong> Monomorphization</a></li><li class="chapter-item "><a href="backend/lowering-mir.html"><strong aria-hidden="true">54.</strong> Lowering MIR</a></li><li class="chapter-item "><a href="backend/codegen.html"><strong aria-hidden="true">55.</strong> Code Generation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="backend/updating-llvm.html"><strong aria-hidden="true">55.1.</strong> Updating LLVM</a></li><li class="chapter-item "><a href="backend/debugging.html"><strong aria-hidden="true">55.2.</strong> Debugging LLVM</a></li><li class="chapter-item "><a href="backend/backend-agnostic.html"><strong aria-hidden="true">55.3.</strong> Backend Agnostic Codegen</a></li><li class="chapter-item "><a href="backend/implicit-caller-location.html"><strong aria-hidden="true">55.4.</strong> Implicit Caller Location</a></li></ol></li><li class="chapter-item "><a href="profile-guided-optimization.html"><strong aria-hidden="true">56.</strong> Profile-guided Optimization</a></li><li class="chapter-item "><a href="llvm-coverage-instrumentation.html"><strong aria-hidden="true">57.</strong> LLVM Source-Based Code Coverage</a></li><li class="chapter-item "><a href="sanitizers.html"><strong aria-hidden="true">58.</strong> Sanitizers Support</a></li><li class="chapter-item "><a href="debugging-support-in-rustc.html"><strong aria-hidden="true">59.</strong> Debugging Support in the Rust Compiler</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="appendix/background.html">附录 A: Background topics</a></li><li class="chapter-item affix "><a href="appendix/glossary.html">附录 B: Glossary</a></li><li class="chapter-item affix "><a href="appendix/code-index.html">附录 C: Code Index</a></li><li class="chapter-item affix "><a href="appendix/compiler-lecture.html">附录 D: Compiler Lecture Series</a></li><li class="chapter-item affix "><a href="appendix/bibliography.html">附录 E: Bibliography</a></li><li class="chapter-item affix "><a href="appendix/humorust.html">附录 Z: HumorRust</a></li><li class="spacer"></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">RustcDevGuideZh</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/RustcRustc/rustc-dev-guide-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#宏展开" id="宏展开">宏展开</a></h1>
<!-- toc -->
<blockquote>
<p><code>rustc_ast</code>, <code>rustc_expand</code>, 和 <code>rustc_builtin_macros</code> 都在重构中，所以本章节中的部分链接可能会打不开。</p>
</blockquote>
<p>Rust 有一个非常强大的宏系统。在之前的章节中，我们了解了解析器（parser）如何预留要展开的宏（使用临时的<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/placeholders/index.html">占位符</a> ）。这个章节将介绍迭代地展开这些宏的过程，直到我们的 crate 会有一个完整的 AST，且没有任何未展开的宏（或编译错误）。</p>
<p>首先，我们将讨论宏展开和集成并输出到 ASTs 中的算法。随后，我们将看到健全的（hygiene）数据是如何被收集的。最后，我们将研究展开不同种类宏的细节。</p>
<p>非常多的算法和数据结构都在 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/index.html"><code>rustc_expand</code></a> 中，基础数据结构在 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/index.html"><code>rustc_expand::base</code></a> 中。</p>
<p>还要注意的是，<code>cfg</code> 和 <code>cfg_attr</code> 是其他宏中被特殊处理的，并在 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/config/index.html"><code>rustc_expand::config</code></a> 中处理。</p>
<h2><a class="header" href="#展开和-ast-集成" id="展开和-ast-集成">展开和 AST 集成</a></h2>
<p>首先，展开是发生在 crate 层面。给定一个 crate 的原始代码，编译器将生成一个包含所有宏展开、所有模块内联、等的巨大的 AST。这个过程的主要入口是在  <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/expand/struct.MacroExpander.html#method.fully_expand_fragment"><code>MacroExpander::fully_expand_fragment</code></a> 方法中。除了少数例外情况，我们整个 crate 上都使用这个方法（获得更详细的关于边缘案例的扩展的讨论，请参考 <a href="#eager-expansion">&quot;eager-expansion&quot;</a>，）。</p>
<p>在更高层次上，<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/expand/struct.MacroExpander.html#method.fully_expand_fragment"><code>fully_expand_fragment</code></a> 在迭代（反复）运行的，我们将保留一个未解析的宏调用队列（即尚未找到定义的宏）。我们反复地在队列中选择一个宏，对其进行解析，扩展，并将其集成回去。如果我们无法在迭代中取得进展，这代表着存在编译错误。算法如下 <a href="https://github.com/rust-lang/rust/pull/53778#issuecomment-419224049">algorithm</a>:</p>
<ol start="0">
<li>初始化一个队列（<code>queue</code>）用于保存未解析的宏调用。</li>
<li>反复直到队列（<code>queue</code>）晴空（或者没有任何进展，即有错误）
<ol start="0">
<li>尽可能地在我们已部分构建的 create 中<a href="./name-resolution.html">解析（Resolve）</a>  导入（imports）。</li>
<li>从我们部分已构建的  crate （类似方法、属性、派生）中尽可能多得收集宏<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/expand/struct.Invocation.html"><code>调用</code></a>，并将它们添加到队列中。</li>
<li>将第一元素从队列中取出，并尝试解析它。</li>
<li>如果它被成功解析：
<ol start="0">
<li>
<p>运行宏扩展器（macro's expander）函数，该函数消费（consumes）一个 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/tokenstream/struct.TokenStream.html"><code>TokenStream</code></a> 或 AST 并生成一个 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/tokenstream/struct.TokenStream.html"><code>TokenStream</code></a>或 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/expand/enum.AstFragment.html"><code>AstFragment</code></a> (取决于宏的种类). (<code>TokenStream</code>是一个<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/tokenstream/enum.TokenTree.html"><code>TokenTree</code>s</a> 的集合，
每一个都是一个 token （标点、标识符或文字）或被分隔的组合（在<code>()</code>/<code>[]</code>/<code>{}</code>中的任何内容）
现在，我们以及知道了宏本身的一切，并且可以调用 <code>set_expn_data</code> 去填满全局数据重的属性；这是与 <code>ExpnId</code> 相关的 hygiene data 。（见<a href="#hygiene-and-hierarchies">下文&quot;hygiene&quot;章节</a>）</p>
</li>
<li>
<p>将 AST 集成到一个现有的大型的 AST 中。从本质上讲，这是“类似 token 的块” 变成适当的固定的 AST 并带有 side-tables。
它的发生过程如下：</p>
<ul>
<li>如果宏产生 tokens（例如 proc macro），我们将其解析为 AST ，这可能会产生解析错误。</li>
<li>在展开的过程中，我们构建  <code>SyntaxContext</code>s (hierarchy 2). （见<a href="#hygiene-and-hierarchies">下文&quot;hygiene&quot;章节</a>）</li>
<li>这三个过程在每个刚从宏展开的 AST 片段上依次地发生：
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/node_id/struct.NodeId.html"><code>NodeId</code></a>s 由<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/expand/struct.InvocationCollector.html"><code>InvocationCollector</code></a> 分配的。这还会从新的 AST 片段中收集新的宏调用，并将它们添加到队列中。</li>
<li><a href="https://rustc-dev-guide.rust-lang.org/hir.html?highlight=def,path#identifiers-in-the-hir">&quot;Def paths&quot;</a> 被创建，同时 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/def_id/struct.DefId.html"><code>DefId</code></a>s 由
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_resolve/def_collector/struct.DefCollector.html"><code>DefCollector</code></a> 分配的。</li>
<li>名字由 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_resolve/build_reduced_graph/struct.BuildReducedGraphVisitor.html"><code>BuildReducedGraphVisitor</code></a> 放入模块中（从解析器（resolver's）的角度来看）。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>在展开单个宏并集成输出后，继续执行
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/expand/struct.MacroExpander.html#method.fully_expand_fragment"><code>fully_expand_fragment</code></a> 的下一个迭代。</p>
</li>
</ol>
</li>
<li>如果它没有被成功解析：
<ol start="0">
<li>将宏放回队列中</li>
<li>继续下一个迭代。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3><a class="header" href="#错误恢复" id="错误恢复">错误恢复</a></h3>
<p>如果我们在一次迭代中没有取得任何进展，那么我们就遇到了编译错误(例如一个未定义的宏或导入)。为了进行诊断，我们尝试从错误(未解析的宏或导入)中恢复。这允许编译在第一个错误之后继续进行，这样我们就可以一次报告更多错误。恢复不能使得编译通过。我们知道在这一节点上它会失败。恢复是通过将未成功解析的宏展开为 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/ast/enum.ExprKind.html#variant.Err"><code>ExprKind::Err</code></a> 来实现的。</p>
<h3><a class="header" href="#名称解析" id="名称解析">名称解析</a></h3>
<p>注意，这里涉及到名称解析：我们需要解析上述算法中的导入和宏名。这在 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_resolve/macros/index.html"><code>rustc_resolve::macros</code></a> 中完成，它解析宏路径，验证这些解析，并报告各种错误(例如:“未找到”或“找到了，但它不稳定（unstable）”或“预期的x，但发现的y”)。但是，我们还没有尝试解析其他名称。这将在后面发生，我们将在<a href="./name-resolution.html">下一章</a>中看到。</p>
<h3><a class="header" href="#eager-expansion" id="eager-expansion">Eager Expansion</a></h3>
<p><em>Eager expansion</em> 代表着我们在展开宏调用之前，先展开宏调用的参数。这仅对少数需要文字的特殊内置宏实现；首先对其中的一些宏展开参数可以获得更流畅的用户体验。作为一个例子，请考虑下属情况：</p>
<pre><code class="language-rust ignore">macro bar($i: ident) { $i }
macro foo($i: ident) { $i }

foo!(bar!(baz));
</code></pre>
<p>lazy expansion 会首先扩展 <code>foo!</code> ，eager expansion 会扩展 <code>bar!</code>。</p>
<p>Eager expansion 不是一个普遍的（通用的） Rust 特性（feature）。实现更加普遍的 eager expansion 是具有挑战性的，但是为了用户体验，我们为一些内置宏实现了它（eager expansion）。内置宏是在 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_builtin_macros/index.html"><code>rustc_builtin_macros</code></a> 实现，还有一些其他早期的代码生成工具，例如注入标准库的导入或生成测试的工具。在 [<code>rustc_expand::build</code>] 有一些额外的帮助工具来构建 AST 片段（fragments）。Eager expansion 通常执行 lazy (normal) expansion 来展开子集。它是通过只在一个部分的 crate 的上来调用 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/expand/struct.MacroExpander.html#method.fully_expand_fragment"><code>fully_expand_fragment</code></a> 来完成的。（与我们通常使用整个 crate 来调用相反）。</p>
<h3><a class="header" href="#其他数据结构" id="其他数据结构">其他数据结构</a></h3>
<p>以下是涉及到扩展和扩展的其他重要数据结构</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/trait.ResolverExpand.html"><code>ResolverExpand</code></a> - 一个用来阻隔（break）crate 的依赖的 trait。这允许解析服务在 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/index.html"><code>rustc_ast</code></a> 中使用，虽然 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_resolve/index.html"><code>rustc_resolve</code></a> 和 几乎所有其他的东西都依赖于 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/index.html"><code>rustc_ast</code></a> 。</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/struct.ExtCtxt.html"><code>ExtCtxt</code></a>/<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/struct.ExpansionData.html"><code>ExpansionData</code></a> - 用来保存在处理过程中各种中间数据。</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/enum.Annotatable.html"><code>Annotatable</code></a> - 可以作为属性目标的 AST 片段。几乎和 AstFragment 相同，除了类型和可以由宏生成但不能用属性注释。</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/trait.MacResult.html"><code>MacResult</code></a> - 一个“多态的” AST 片段，可以根据他的 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/expand/enum.AstFragmentKind.html"><code>AstFragmentKind</code></a>（item、expression、pattern）转换成不同的 <code>AstFragment</code>。</li>
</ul>
<h2><a class="header" href="#hygiene-和结构层次" id="hygiene-和结构层次">hygiene 和结构层次</a></h2>
<p>如果您曾使用过 C/C++  预处理器宏，就会知道有一些烦人的、难以调试的陷阱！例如，考虑以下代码：</p>
<pre><code class="language-c">#define DEFINE_FOO struct Bar {int x;}; struct Foo {Bar bar;};

// Then, somewhere else
struct Bar {
    ...
};

DEFINE_FOO
</code></pre>
<p>大多数人都避免这样写 C - 因为他无法通过编译。宏定义的 <code>struct Bar</code> 与代码中的结构 <code>struct Bar</code> 定义冲突。请再考虑以下代码：</p>
<pre><code class="language-c">#define DO_FOO(x) {\
    int y = 0;\
    foo(x, y);\
    }

// Then elsewhere
int y = 22;
DO_FOO(y);
</code></pre>
<p>你看到任何问题了吗？我们想去生成调用  <code>foo(22, 0)</code> 但是我们得到了 <code>foo(0, 0)</code> ，因为在宏中已经定义了 <code>y</code>! </p>
<p>这两个都是 <em>macro hygiene</em> 问题的例子。 <em>Hygiene</em>  关于如何处理名字定义在宏中。特别是，一个健康的宏系统可以防止由于宏中引入的名称而产生的错误。Rust 宏是卫生的（hygienic），因为不允许编写上述的 bugs。</p>
<p>在更高层次上，rust 编译器的卫生（hygiene）性是通过跟踪定义（引入）和使用名称的上下文来保证的。然后我们可以根据上下文消除名字的歧义。宏系统未来的迭代将允许宏的编写者更好地控制该上下文。例如宏的编写者可能想在宏调用的上下文中定义（引入）一个新的名称。另一种情况是，宏的编写者只在宏的作用域内使用变量（也就是说在宏的外部不可见）。</p>
<p>上下文被添加到 AST 节点。所有由宏生成的 AST 节点都附加了上下文。此外，可能还有些具有上下文的节点，例如一些解析语法糖（非宏展开节点被认为只有 root 上下文，将在后面阐述）。这个编译器，我们使用 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html"><code>rustc_span::Span</code>s</a> 定位代码的位置。这个结构同样有卫生（hygiene）性信息，我们将在后面看到。</p>
<p>因为宏调用和定义可以是嵌套的，所以节点的语法上下文也必须是有层次的。比如说，如果我们扩展一个宏，有一个宏调用或者定义在生成的输出中，那么语法上下文应该反映出嵌套。</p>
<p>然而，事实证明，出于不同目的，我们实际上需要跟踪一些类型的上下文。因此一个 crate 的卫生（hygiene）信息不只是由一个而是由三个扩展层次构成的。</p>
<p>所有层次结构都需要某种 &quot;macro ID&quot; 来标识展开链中的单个元素。这个 ID 是 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.ExpnId.html"><code>ExpnId</code></a>。所有的宏收到一个整数 ID ，当我们发现新的宏调用时，从 0 开始自增。所有层次结构都是从 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.ExpnId.html#method.root"><code>ExpnId::root()</code></a> 开始的（当前层次的父节点）。</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/index.html"><code>rustc_span::hygiene</code></a> 包含了所有卫生（hygiene）相关的算法（<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_resolve/struct.Resolver.html#method.resolve_crate_root"><code>Resolver::resolve_crate_root</code></a> 中的一些 hacks 在除外）和卫生（hygiene）相关的数据结构，这些结构都保存在全局数据中。</p>
<p>实际的层次结构存储在 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.HygieneData.html"><code>HygieneData</code></a> 中。这是一个全局数据，包含将装修和展开信息，可以从任意的 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Ident.html"><code>Ident</code></a> 访问，无需任何上下文。</p>
<h3><a class="header" href="#展开顺序层次结构" id="展开顺序层次结构">展开顺序层次结构</a></h3>
<p>第一，层次结构将跟踪展开的顺序，即宏调用出现在另一个宏的输出中。</p>
<p>在这里，层次结构中的子元素将被标记为“最内层的”，<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.ExpnData.html"><code>ExpnData</code></a> 结构自身包含宏定义和宏调用的属性子集，这些属性是全局可用的。<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.ExpnData.html#structfield.parent"><code>ExpnData::parent</code></a> 在当前层次结构中，跟踪 子节点 -&gt; 父节点的链接。</p>
<p>例如</p>
<pre><code class="language-rust ignore">macro_rules! foo { () =&gt; { println!(); } }

fn main() { foo!(); }
</code></pre>
<p>在代码中，AST 节点最终会生成以下层次结构。</p>
<pre><code>root
    expn_id_foo
        expn_id_println
</code></pre>
<h3><a class="header" href="#宏定义的结构层次" id="宏定义的结构层次">宏定义的结构层次</a></h3>
<p>第二，层次结构将跟踪宏定义的顺序。即我们展开一个宏，在其输出中出现另一个宏定义。这个层次结构比其他两个结构层次更复杂，更棘手。</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.SyntaxContext.html"><code>SyntaxContext</code></a>  通过 ID 表示此层次结构中的整个链。<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.SyntaxContextData.html"><code>SyntaxContextData</code></a> 包含了与给定的 
<code>SyntaxContext</code> 相关的数据；大多数情况下，它是一个缓存，用于以不同方式过滤该链的结果。<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.SyntaxContextData.html#structfield.parent"><code>SyntaxContextData::parent</code></a> 是此处 子节点-&gt; 父节点 的链接，<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.SyntaxContextData.html#structfield.outer_expn"><code>SyntaxContextData::outer_expns</code></a> 是链中的各个元素。“链接运算符”在编译器代码中是<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.SyntaxContext.html#method.apply_mark"><code>SyntaxContext::apply_mark</code></a>。</p>
<p>上述提到的 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html"><code>Span</code></a> 实际上只是代码位置和 <code>SyntaxContext</code> 的紧凑表现。同样的，<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Ident.html"><code>Ident</code></a> 只是
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Symbol.html"><code>Symbol</code></a> + <code>Span</code>（即一个被替换的字符串+健全性数据）</p>
<p>对于内置宏，我们使用 <code>SyntaxContext::empty().apply_mark(expn_id)</code> 上下文，这样的宏是被认为是定义在 root 层次结构纸上。我们为 proc-macros 做一样的事，因为我们还没有实现跨 crate 并保证其卫生（hygiene）。</p>
<p>如果 token 在宏生成之前有上下文 <code>X</code> ，那么在宏生成后上下文会有 <code>X -&gt; macro_id</code>。以下是一些例子：</p>
<p>Example 0:</p>
<pre><code class="language-rust ignore">macro m() { ident }

m!();
</code></pre>
<p>这里 <code>ident</code> 有最初的上下文 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.SyntaxContext.html#method.root"><code>SyntaxContext::root()</code></a>。在 <code>m</code> 生成后，<code>ident</code> 会有上下文 <code>ROOT -&gt; id(m)</code>。</p>
<p>Example 1:</p>
<pre><code class="language-rust ignore">macro m() { macro n() { ident } }

m!();
n!();
</code></pre>
<p>这个例子中，<code>ident</code> 有最初的 <code>ROOT</code>  ，在第一个宏被展开后上下文变为 <code> ROOT -&gt; id(m)</code> ，继续展开后得到上下文 <code>ROOT -&gt; id(m) -&gt; id(n)</code>。</p>
<p>Example 2:</p>
<p>注意，这些链并不完全由他们最后的一个元素决定，换句话来说 <code>ExpnId</code> 和 <code>SyntaxContext</code> 不是同构的。</p>
<pre><code class="language-rust ignore">macro m($i: ident) { macro n() { ($i, bar) } }

m!(foo);
</code></pre>
<p>在所有展开后，<code>foo</code> 有上下文 <code>ROOT -&gt; id(n)</code> ，<code>bar</code> 有上下文
<code>ROOT -&gt; id(m) -&gt; id(n)</code>。</p>
<p>最后要提的一点是，目前的结构层次受限于 <a href="https://github.com/rust-lang/rust/pull/51762#issuecomment-401400732">&quot;context transplantation hack&quot;</a> 。基本上，更现代（实现性的）宏（<code>macro</code>） 比旧的 MBE 系统有更强的卫生（hygiene）性，但这可能导致两者之间奇怪的交互。这种 hack 实现是为了让所有事暂时“正常工作”。</p>
<h3><a class="header" href="#调用的结构层次" id="调用的结构层次">调用的结构层次</a></h3>
<p>第三也是最后一个，结构层次是跟踪宏调用的位置。</p>
<p>在结构层次 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.ExpnData.html#structfield.call_site"><code>ExpnData::call_site</code></a> 中是 子节点 -&gt; 父节点 的链接。</p>
<p>这里有一个例子：</p>
<pre><code class="language-rust ignore">macro bar($i: ident) { $i }
macro foo($i: ident) { $i }

foo!(bar!(baz));
</code></pre>
<p>对于 <code>baz</code> AST 节点是最后输出的，第一个结构层次是 <code>ROOT -&gt; id(foo) -&gt; id(bar) -&gt; baz</code> ，而第三结构层次是 <code>ROOT -&gt; baz</code>。</p>
<h3><a class="header" href="#宏回溯" id="宏回溯">宏回溯</a></h3>
<p>在 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/index.html"><code>rustc_span</code></a> 中实现了宏回溯，其使用了 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/index.html"><code>rustc_span::hygiene</code></a> 的健全机制。</p>
<h2><a class="header" href="#产生宏输出" id="产生宏输出">产生宏输出</a></h2>
<p>上述内容中我们看到了中的宏的输出如何被集成到用于 crate 的 AST 中，我们还看到了如何为一个 crate 生成卫生（hygiene）数据。但是我们如何实际产生一个宏的输出呢？这将取决于宏的类型。</p>
<p>Rust 中有两种类型的宏：<code>macro_rules!</code> 类型（或称 示例宏（ Macros By Example,MBE））和过程宏（procedural macros）（或 proc macros;包括自定义派生）。在解析阶段，正常的 Rust 解析器将保留宏及其调用内容。稍后将使用这部分代码将宏展开。</p>
<p>这里有一些重要的数结构和接口：</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/struct.SyntaxExtension.html"><code>SyntaxExtension</code></a> - 一个更底层的宏表示，包含了它扩展函数，他将一个 token 流（<code>TokenStream</code>）或 AST 转换成另一个 <code>TokenStream</code> 或 AST 加上一些额外信息，例如稳定性，或在宏内允许使用的不稳定特性的列表。</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/enum.SyntaxExtensionKind.html"><code>SyntaxExtensionKind</code></a> - 展开方法可能会有很多不同的函数签名（接受一个 token 流，或者两个；或者接受一部分 AST 等等）。这是一个列出他们的枚举。</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/trait.ProcMacro.html"><code>ProcMacro</code></a>/<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/trait.TTMacroExpander.html"><code>TTMacroExpander</code></a>/<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/trait.AttrProcMacro.html"><code>AttrProcMacro</code></a>/<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/trait.MultiItemModifier.html"><code>MultiItemModifier</code></a> - traits 用于标识展开函数的签名</li>
</ul>
<h2><a class="header" href="#示例宏macros-by-example" id="示例宏macros-by-example">示例宏（Macros By Example）</a></h2>
<p>MBEs 有自己等等解析器，不同于普通的 Rust 解析器。当宏展开时，我们可以调用 MBE 解析器去解析和展开宏。反过来，MBE 解析器在解析宏调用的内容时需要绑定元变量（例如<code>$my_expr</code>），这可能会调用普通的 Rust 解析器。宏展开的代码在 <a href="https://github.com/rust-lang/rust/tree/master/compiler/rustc_expand/src/mbe"><code>compiler/rustc_expand/src/mbe/</code></a></p>
<h3><a class="header" href="#示例" id="示例">示例</a></h3>
<p>有个例子供参考提供是有助的。在本章的其他部分，每当我们提到 &quot;示例 <em>定义</em>&quot; 时，我们指得失以下内容：</p>
<pre><code class="language-rust ignore">macro_rules! printer {
    (print $mvar:ident) =&gt; {
        println!(&quot;{}&quot;, $mvar);
    };
    (print twice $mvar:ident) =&gt; {
        println!(&quot;{}&quot;, $mvar);
        println!(&quot;{}&quot;, $mvar);
    };
}
</code></pre>
<p><code>$mvar</code> 是一个 <em>元变量</em> 。与正常的变量不同，元变量不是绑定到计算中的值，而是在 <em>编译时</em> 绑定到 <em>tokens</em> 树。 <em>token</em> 是一个单独的语法“单元”，例如标识符（例 <code>foo</code>）或者标点符号（例 <code>=&gt;</code>）。还有其他特殊的 tokens，例如  <code>EOF</code> 他表示没有其他更多的 tokens。Token 树由类似成对的圆括号的字符(<code>(</code>...<code>)</code>,
<code>[</code>...<code>]</code>, 和 <code>{</code>...<code>}</code>) - 他们包括了 open 和 close，以及它们之间的所有标记（我们确实要求类似括号的字符需要保持要平衡）。让宏展开操作 token 流而不是源文件的原始字节，从而减少复杂性。宏扩展器（以及编译器的其余大多数）实际上并不十分在乎代码中某些语法构造的确切行和列。它只关心代码中使用了哪些构造。使用 tokens 使得我们可以关心 <em>什么</em> 而不必担心在 <em>哪里</em> ，关于 tokens 跟多内容，可以参考本书 <a href="./the-parser.html">Parsing</a> 一章。</p>
<p>当我们提到 “示例 <em>调用</em>” ，我们指以下代码片段：</p>
<pre><code class="language-rust ignore">printer!(print foo); // Assume `foo` is a variable defined somewhere else...
</code></pre>
<p>将宏调用展开为语法树的过程 <code>println!(&quot;{}&quot;, foo)</code> ，然后展开成 
<code>Display::fmt</code> 调用成为 <em>宏展开</em> ，是本章的主题。</p>
<h3><a class="header" href="#示例宏-mbe-解析器" id="示例宏-mbe-解析器">示例宏 （MBE） 解析器</a></h3>
<p>MBE 展开包括两个部分：解析定义和解析调用。有趣的是，两者都是由宏解析器完成的。</p>
<p>基本上，MBE 解析器类似于基于 NFA 的正则解析器。它使用的算法本质上类似于 <a href="https://en.wikipedia.org/wiki/Earley_parser">Earley parsing
algorithm</a> 。 宏解析器定义在 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/mbe/macro_parser"><code>compiler/rustc_expand/src/mbe/macro_parser.rs</code></a>。</p>
<p>宏解析器的接口如下（稍作简化）：</p>
<pre><code class="language-rust ignore">fn parse_tt(
    parser: &amp;mut Cow&lt;Parser&gt;,
    ms: &amp;[TokenTree],
) -&gt; NamedParseResult
</code></pre>
<p>我们在宏解析器中使用这些项：</p>
<ul>
<li><code>parser</code> 是一个对普通 Rust 解析器的引用，包括了 token 流和解析会话（parsing session）。Token 流是我们将请求 MBE 解析器解析的内容。我们将使用原始的 token 流，将元变量绑定到对应的 token 树。解析会话（parsing session）可用于报告解析器错误。</li>
<li><code>ms</code> 是一个 <em>匹配器</em> 。这是一个 token 树序列，我们希望以此来匹配 token 树。</li>
</ul>
<p>类似于正则解析器，token 流是输入，我们将其与 pattern <code>ms</code> 匹配。使用我们的示例，token 流可以是包含示例 <em>调用</em> <code>print foo</code> 内部的 token 流，<code>ms</code> 可以是 token（树）<code>print $mvar:ident</code>。</p>
<p>解析器的输出是 <code>NamedParseResult</code>，它指示发生了三种情况中的哪一种：</p>
<ul>
<li>成功：token 流匹配给定的匹配器 <code>ms</code>，并且我们已经产生了从元变量到响应令牌树的绑定。</li>
<li>失败：token 流与 <code>ms</code> 不匹配。浙江导致出现错误消息，例：“No rule expected token <em>blah</em>”</li>
<li>错误： 解析器中发生了一些致命的错误。例如，如果存在多个模式匹配，则会发生这种情况，因为这表明宏不明确。</li>
</ul>
<p>所有的接口定义在 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/mbe/macro_parser/fn.parse_tt.html">这里</a>。</p>
<p>宏解析器的工作与普通的正则解析器几乎相同，只有一个例外：为了解析不通的元变量，例如<code>ident</code>, <code>block</code>, <code>expr</code> 等，宏解析器有时候必须回调到普通的 Rust 解析器。</p>
<p>如上所述，宏的定义和调用都使用宏解析器进行解析。这是非常不直观和自引用的。
解析宏的代码定义在 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/mbe/macro_rules"><code>compiler/rustc_expand/src/mbe/macro_rules.rs</code></a> 中。它定义用于匹配宏定义模式为 <code>$( $lhs:tt =&gt; $rhs:tt );+</code> 。换句话说，一个 <code>macro_rules</code> 定义在其主体中应最少出现一个 token 树，后面跟着 <code>=&gt;</code>，然后是另一个 token 树。当编译器遇到 <code>macro_rules</code> 定义时，它使用这个模式来匹配定义中每个规则的两个 token 树， <em>并使用宏解析器本身</em> 。在示例定义中，元变量 <code>$lhs</code> 将会匹配 partten <code>(print $mvar:ident)</code> 和 <code>(print twice $mvar:ident)</code>。 <code>$rhs</code> 将匹配 <code>{ println!(&quot;{}&quot;, $mvar); }</code> 和 <code>{ println!(&quot;{}&quot;, $mvar); println!(&quot;{}&quot;, $mvar); }</code> partten 的主体。解析器将保留这些内容，以便在需要展开宏调用时使用。</p>
<p>当编译器遇到宏调用时，它会使用上述基于 NFA 的宏解析器解析该调用。但是，使用的匹配器是从宏定义的 arms 中提取的第一个 token 树（<code>$lhs</code> ），使用我们的示例，我们尝试匹配 token 流中的 <code>print foo</code> （来自匹配器的） <code>print $mvar:ident</code> 和从前面定义中提取的 <code>print twice $mvar:ident</code>。算法是完全相同的，但是当宏解析器在当前匹配其中需要匹配非 <em>non-terminal</em>  (例如 <code>$mvar:ident</code>) 时，它会回调正常的 Rust 解析器以获取该非终结符的内容。这种情况下，Rust 会寻找一个 <code>ident</code> token，它会找到 <code>foo</code> 并返回给宏解析器。然后，宏解析器照常进行解析。另外，请注意来自于不同 arms 的匹配器应该恰好有一个匹配调用；如果有多个匹配项，则该解析有二义性，而如果根本没有匹配项，则存在语法错误。</p>
<p>跟多关于解析器实现的信息请参考 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/mbe/macro_parser"><code>compiler/rustc_expand/src/mbe/macro_parser.rs</code></a></p>
<h3><a class="header" href="#macros-and-macros-20" id="macros-and-macros-20"><code>macro</code>s and Macros 2.0</a></h3>
<p>改进 MBE 系统，为它提供更多与卫生（hygiene）性相关的功能，更好的范围和可见性规则等，这是一个古老的，几乎没有文献记载的工作。不幸的是，最近在这方面还没有进行很多工作。 在内部，宏使用与当今的 MBE 相同的机制。 它们只是具有附加的语法糖，并且允许在名称空间中使用。</p>
<h2><a class="header" href="#过程procedural宏" id="过程procedural宏">过程（Procedural）宏</a></h2>
<p>如上所述，过程宏也在解析过程中进行了扩展。 但是，它们使用了一种完全不同的机制。 过程宏不是作为编译器中的解析器，而是作为自定义的第三方 crate 实现的。 编译器将在其中编译 proc macro crate 和带有特殊注释的函数（即 proc macro 本身），并向它们传递 tokens 流。</p>
<p>然后 proc macro 可以转换 token 流和输出新的 token 流，该 token 流被合称为 AST。</p>
<p>值得注意的是，proc macros 使用的 token 流类型是 <em>稳定的</em> ，因此<code>rustc</code> 不在内部使用它（因为内部数据结构是不稳定的）。 像以前一样，编译器的 token 流为 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/tokenstream/struct.TokenStream.html"><code>rustc_ast::tokenstream::TokenStream</code></a>。 这将转换为稳定的 <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>proc_macro::TokenStream</code></a> 并返回 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/proc_macro/index.html"><code>rustc_expand::proc_macro</code></a> 和<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/proc_macro_server/index.html"><code>rustc_expand::proc_macro_server</code></a> 。 因为 Rust ABI 不稳定，所以我们使用 C ABI 进行转换。</p>
<p>TODO: more here.</p>
<h3><a class="header" href="#custom-derive" id="custom-derive">Custom Derive</a></h3>
<p>自定义派生是 proc macro 的一种特殊类型。 </p>
<p>TODO: more?</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="the-parser.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="name-resolution.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="the-parser.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="name-resolution.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
